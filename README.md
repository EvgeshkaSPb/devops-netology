# Домашнее задание к занятию "6.6. Troubleshooting"


## Обязательная задача 1

Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.
Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.
Вы как инженер поддержки решили произвести данную операцию:
напишите список операций, которые вы будете производить для остановки запроса пользователя
```
Для поиска текщих операции
db.currentOp() Как вариант db.currentOp({“secs_running”: {$gte: 120}}) - оперции выполняющиеся дольше 2 минут.
Для остановки нужной операции
db.killOp(opid)
```
предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

~~Проблема "медленных" запросов, как правило, возникает из-за отстуствия правильных индексов. Необходимо пересотрить соответсвующий индекс и проблема будет решена.~~
```
Как правило, такая проблема возникает из-за неэффективного плана выполнения запроса. MongoDB нужны правильные индексы для эффективного поиска по документам.
Для этого нужно проделать следующие действия:
db.currentOp() -получаем информацию по меддленному запросу и берем данные в следующий запрос
db.custom_data.find({"application_id" : ,"class_name" : "Logs","UniqueId" : }).explain('executionStats') -Получаем развернутый план выполнения целевого запроса. 
Первое, что нас интересует значение "docsExamined" - оно показывает количество запрошенных документов. В случае неэффективного запроса это количство значительно больше 1(идеальное значение).
Далее indexName - показывает нам "неправильный" индекс, который нужно пересоздать.
 db.collection.createIndex() - пересоздаем целевой индекс.
```

## Обязательная задача 2

Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.
Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.
При масштабировании сервиса до N реплик вы увидели, что:
сначала рост отношения записанных значений к истекшим
Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?
```
Проблема может быть в "истекающих" ключах. Если в БД истекает 25%(и более) ключей одновременно(в одну секунду времени), то Redis может блокировать операции, пока количество одновременно истекающих ключей не станет менее 25%.
```

## Обязательная задача 3

Перед выполнением задания познакомьтесь с документацией по Common Mysql errors.
Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?
```
Возможно проблема появилась из-за слишком большого количества строк в запросе.
В любом случае, изначально стоит проверить состояние сетевых интерфесов на наличие ошибок (возможно проблема в сети).
Далее смотрим "размер" самого запроса.
Следующим шагом проверяем SHOW GLOBAL STATUS LIKE 'Aborted_connects' на "не прошедшие соединения".
```
Какие пути решения данной проблемы вы можете предложить?
```
Увеличение параметров net_read_timeout и connect_timeout в два раза =).
```

## Обязательная задача 4
Перед выполнением задания ознакомтесь со статьей Common PostgreSQL errors из блога Percona.
Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
postmaster invoked oom-killer
Как вы думаете, что происходит?
```
Я думаю что серверу не хватает памяти, и сервер отключает процессы. 
# Linux может зарезервировать для процессов больше памяти, чем есть, но не выделять ее по факту.
```
Как бы вы решили данную проблему?

~~Самый простой путь - увелечение количества памяти доступной серверу.~~
```
Необходимо установка значения в параметр:
vm.overcommit_memory=2
В таком случае ядро не будет резервировать больше памяти, чем указано в параметре overcommit_ratio.
Дополнительно изменить пееменную /proc/sys/vm/swappiness - Эти значения указывают ядру, как обрабатывать подкачку страниц. 
Чем больше значение, тем меньше вероятности, что OOM завершит процесс, но из-за операций ввода-вывода это негативно сказывается на базе данных. 
И наоборот — чем меньше значение, тем выше вероятность вмешательства OOM-Killer, но и производительность базы данных тоже выше.
```
